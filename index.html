<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Simplefeed by ICT4H</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Simplefeed</h1>
        <p>A simple Atom-based protocol for broadcasting a feed of events.</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/ICT4H/simplefeed" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/ICT4H/simplefeed/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/ICT4H/simplefeed/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>Simplefeed</h1>

<h2>What is Atom?</h2>

<p><a href="http://en.wikipedia.org/wiki/Atom_(standard)">Atom</a> is an XML-based syndication format which represents time-ordered series of events. In Atom terminology, each event is an <em>entry</em> and the series of events is a <em>feed</em>.</p>

<p>Both feeds and entries have metadata associated with them, for example a title and a unique identifier. They can also have links with a <em>rel</em> attribute describing the relationship the link represents, for example a link with rel "self" that points back to the selfsame entry or feed.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Notifications&lt;/title&gt;
        &lt;updated&gt;2013-01-02T10:03:00Z&lt;/updated&gt;
        &lt;generator&gt;Foo CMS&lt;/generator&gt;
        &lt;link rel="self" href="http://example.com/documents/2" /&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:eb3ee5a0-75be-11e2-bcfd-0800200c9a66&lt;/id&gt;
            &lt;title type="text"&gt;Edit&lt;/title&gt;
            &lt;updated&gt;2013-01-02T10:01:00Z&lt;/updated&gt;
            &lt;author&gt;
                &lt;name&gt;jsmith&lt;/name&gt;
            &lt;/author&gt;
            &lt;link rel="self" href="http://example.com/entry/33" /&gt;
            &lt;content type="application/vnd.example.document+xml"&gt;
                &lt;title&gt;HR policies&lt;/title&gt;
                &lt;link href="http://example.com/cms/pdf/456" /&gt;
            &lt;/content&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:1d3334a0-75bd-11e2-bcfd-0800200c9a66&lt;/id&gt;
            &lt;title type="text"&gt;User created&lt;/title&gt;
            &lt;updated&gt;2013-01-02T07:31:00Z&lt;/updated&gt;
            &lt;author&gt;
                &lt;name&gt;dgonzales&lt;/name&gt;
            &lt;/author&gt;
            &lt;link rel="self" href="http://example.com/entry/32" /&gt;
            &lt;content type="application/vnd.example.user+xml"&gt;
                &lt;username&gt;jsmith&lt;/username&gt;
                &lt;role&gt;editor&lt;/role&gt;
                &lt;email&gt;jsmith@example.com&lt;/email&gt;
            &lt;/content&gt;
        &lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>Atom is optimised and designed for RESTful systems that communicate over HTTP.</p>

<p>Atom is a general-purpose format that can be extended to fit a particular domain. By using a well-understood general-purpose format as a basis, we can reuse tools, infrastructure and semantics. The Atom syndication format was formalised in <a href="http://www.ietf.org/rfc/rfc4287">RFC 4287</a>.</p>

<h2>Event-driven systems</h2>

<p>Atom can be used to implement event-driven systems by adding an entry to the feed every time something happens that consumers might be interested in. Consumers find out about these events by polling the feed. When new consumers arrive, they can simply also start polling the feed without any change needed to the feed provider.</p>

<p>Depending on the nature of the event and the size of the resource that it applies to, the Atom entry could either include a snapshot of the new state of the resource, or simply link to the resource so that the client can issue a fresh GET.</p>

<p>Because Atom is based on polling, it has high latency compared to other approaches, which might make it unsuitable for real time systems. However, using a RESTful polling approach decouples client and server, and provides scalability through the opportunity for heavy caching.</p>

<h2>Simplefeed</h2>

<p>We will describe a protocol suitable for broadcasting events to multiple consumers using Atom. To keep things simple, we won't worry about editing or writing to feeds. We will assume that the server providing the feed has some way of recognising and registering new events as Atom entries.</p>

<p>"Atom" can also sometimes refer to <a href="https://tools.ietf.org/html/rfc5023">AtomPub</a>, a protocol for editing and publishing web resources built on top of the Atom XML format. If you need your feed to be editable over HTTP, AtomPub is a good place to start.</p>

<p>As well as conforming to the Atom XML format, our Simplefeed protocol is based on the following rules:</p>

<ul>
<li>Entries are ordered by the time they were added to the feed, from newest at the top of the feed to oldest at the bottom.</li>
<li>An entry, once published, never changes.</li>
<li>The series of entries is paginated over many Atom documents.</li>
<li>All documents except the oldest will have a link with rel "next-archive" pointing to the next document in the feed.</li>
<li>All documents except the newest will have a link with rel "prev-archive" pointing to the previous document in the feed. </li>
<li>Only the newest document, known as the <em>recent document</em>, may change, and that can only change by newer events being prepended to it.</li>
<li>When the feed provider decides the recent document is finished, it archives that document and creates a new document.</li>
<li>There is a published URL that always points to the <em>recent document</em> and serves as an entry point to the feed.</li>
</ul><p>Though it is good practice to use intuitive URLs, the protocol in no way depends on the structure of the URLs. Consumers should follow links, and not attempt to construct URLs themselves.</p>

<h2>Paginating feeds</h2>

<p>As Atom entries are intended to be available indefinitely, the feed of events can grow very large over time. This makes the feed too large for consumers to conveniently GET over a network.</p>

<p>The solution is to break up a single logical feed into many documents. As Atom is designed to follow RESTful conventions, Atom does this by means of links.</p>

<p>The feed provider breaks up the series of events into separate documents and gives each of them their own URL. The provider might choose to make each document represent a period of time e.g. a day, or might divide the series of events evenly so that each document has e.g. 100 entries. </p>

<p>Similar to a doubly-linked list, each document has <em>prev-archive</em> and <em>next-archive</em> links that can be followed to find the next document in the chain.</p>

<p>There are two special cases. Because it is at the head of the list, the recent document cannot have a <em>next-archive</em> link. Similarly, the first document does not have a <em>prev-archive</em> link.</p>

<p>The recent document is the published entry point to the feed. Consumers of the event feed will always be able to retrieve <a href="http://example.com/recent">http://example.com/recent</a> to get the most recent entries.</p>

<p>Documents older than the recent one are known as archived documents. Archived documents do not change after they have been created, but the recent document will continue to have entries prepended to it until the feed provider archives it. This means that caching can be much more agressive for archived documents than the recent document.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Recent notifications&lt;/title&gt;
        &lt;link rel="self" href="http://example.com/recent" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/3" /&gt;
        &lt;!-- There is no "next-archive" link as this is the most recent document. --&gt;
        &lt;link rel="via" href="http://example.com/documents/4" /&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>The recent document can also be accessed through its permanent URL, which is represented with a "via" link. Once the feed provider has archived the current recent document, it will create a new one and leave the via link intact.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Notifications&lt;/title&gt;
        &lt;link rel="self" href="http://example.com/documents/4" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/3" /&gt;
        &lt;!-- There is no "next-archive" link as this is the most recent document. --&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>Consumers who are interested in older entries can follow the "prev-archive" link to the previous document.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Notifications&lt;/title&gt;
        &lt;link rel="self" href="http://example.com/documents/3" /&gt;
        &lt;link rel="next-archive" href="http://example.com/documents/4" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/2" /&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>This document has been archived, and should therefore never change. Consumers wishing to find older or newer entries than the ones in this document can find them by following the "prev-archive" and "next-archive" links respectively. </p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Notifications&lt;/title&gt;
        &lt;link rel="self" href="http://example.com/documents/2" /&gt;
        &lt;link rel="next-archive" href="http://example.com/documents/3" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/1" /&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>This is another archived document, and can also be heavily cached. Finding older or newer entries is again a matter of following the "prev-archive" or "next-archive" links. Consumers who wish to read the entire history can continue to follow "prev-archive" links until they come across a document with no such link, which will be the first.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;id&gt;urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;title type="text"&gt;Notifications&lt;/title&gt;
        &lt;link rel="self" href="http://example.com/documents/1" /&gt;
        &lt;link rel="next-archive" href="http://example.com/documents/2" /&gt;
        &lt;!-- There is no "prev-archive" link as this is the first document. --&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
        &lt;entry&gt;..&lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<h2>Consuming feeds</h2>

<p>A consumer of an Atom feed keeps track of the unique identifier of the most recent entry it has processed. Because the entries are time ordered, and the only change is to add new entries onto the front of the feed, consumers can work backwards till they find the oldest entry they have not yet processed, and then work forwards through the feed processing each event in turn. </p>

<p>For example, a consumer might know that it has most recently processed the entry with id "urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66".</p>

<p>This consumer wants to check if there are any more recent entries, so it issues a GET request on <a href="http://example.com/recent">http://example.com/recent</a>, which is the published entry-point of the feed.</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;link rel="self" href="http://example.com/recent" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/3" /&gt;
        &lt;link rel="via" href="http://example.com/documents/4" /&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:e2089090-75c7-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:d765c950-75c7-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>The entry with id "urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66" is not present. This is because since the consumer last checked the feed, the provider has added new entries to the front of the feed, archiving a document and starting a new one in the process.</p>

<p>The consumer therefore issues a GET request for the previous document, which has the URL "<a href="http://example.com/documents/3">http://example.com/documents/3</a>".</p>

<pre><code>&lt;?xml version="1.0"&gt;
    &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
        &lt;link rel="self" href="http://example.com/documents/3" /&gt;
        &lt;link rel="next-archive" href="http://example.com/documents/4" /&gt;
        &lt;link rel="prev-archive" href="http://example.com/documents/2" /&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:f37a81d0-75c7-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;id&gt;urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66&lt;/id&gt;
        &lt;/entry&gt;
    &lt;/feed&gt;
</code></pre>

<p>This time, the consumer does find the entry it last processed. The consumer can now start to work its way back to the front of the feed, by processing the one new entry in document 3, and then going through the entries in the recent document.</p>

<p>As the consumer goes through the entries, it keeps updating its record of the most recent entry processed. Note that because the series of entries is time-ordered, the client need only keep track of the identifier of the most recent entry it has processed.</p>

<p>Notice that the feed provider does not have to keep track of who the consumers are or which entry they are each up to. The guarantee that new events are always added to the front of the list allows consumers to do that for themselves.</p>

<p><img src="Atom.png" alt="Documents are chained using next-archive and prev-archive links" title="Chaining documents"></p>

<h2>Implementation considerations</h2>

<p>One of the biggest advantages to using Atom is caching. Servers should serve archived documents with aggressive Cache-Control headers, because once a document is archived, it does not change. Servers can take advantage of this by writing archived documents out to disk and serving them as static files.</p>

<p>Note that this caching is possible because the pagination of entries into documents is controlled by the feed provider. If every consumer could decide how to break up the series of entries, we would have to cache many different pagination combinations.</p>

<p>Consumers should not care how pagination is implemented, because they simply follow links and retrieve resources. The provider might choose to break the feed into time periods e.g. a document per day. However, if the flow of events is irregular, that could lead to some documents being very large and others being very small. This can be addressed by keeping a fixed number of entries per document.</p>

<p>Cache-Control headers on the recent document are limited by the freshness requirements of the system. It may still worthwhile allowing consumers and HTTP caches to cache the recent document for a short period of time, as it can reduce load on the server hosting the feed, but the length of time in the header must take into account how quickly consumers need to find out about new events.</p>

<p>For example, in a system with heavy load, using Cache-Control headers with a short time-to-live in conjunction with a reverse proxy gives an upper-bound on how often the server needs to generate the recent document. For example, a time-to-live of 60 seconds means that the origin server will only have to generate the recent document once per minute, regardless of how many consumers there are.</p>

<p>Another useful optimisation for the recent document are ETags and Last-Modified headers. Consumers poll the recent document potentially very often, so if they are able to issue a conditional GET accompanied by an ETag or Last-Modified date then the feed provider can simply reply with a 304 Not Modified response and avoid transferring the entire recent document to the consumer.</p>

<h2>References</h2>

<p>A great reference for understanding Atom's use in RESTful event-driven systems is <a href="http://restinpractice.com/book/">REST in Practice</a> by Jim Webber, Savas Parastatidis and Ian Robinson. We based our description of Simplefeed on Chapter 7.</p>

<p><a href="https://github.com/ICT4H/atomfeed">Atomfeed</a> is a library for using Simplefeed from Java or Java Spring web applications. Currently a work-in-progress.</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/ICT4H">ICT4H</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>