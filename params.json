{"name":"Simplefeed","tagline":"A simple Atom-based protocol for broadcasting a feed of events.","body":"Atom\r\n====\r\n\r\nWhat is Atom?\r\n------------\r\n\r\n[Atom](http://en.wikipedia.org/wiki/Atom_(standard\\)) is an XML-based syndication format which represents time-ordered series of events. In Atom terminology, each event is an *entry* and the series of events is a *feed*.\r\n\r\nBoth feeds and entries have metadata associated with them, for example a title and a unique identifier. They can also have links, for example a \"self\" link that point back to the selfsame entry or feed.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Notifications</title>\r\n            <updated>2013-01-02T10:03:00Z</updated>\r\n            <generator>Foo CMS</generator>\r\n            <link rel=\"self\" href=\"http://example.com/documents/2\" />\r\n            <entry>\r\n                <id>urn:uuid:eb3ee5a0-75be-11e2-bcfd-0800200c9a66</id>\r\n                <title type=\"text\">Edit</title>\r\n                <updated>2013-01-02T10:01:00Z</updated>\r\n                <author>\r\n                    <name>jsmith</name>\r\n                </author>\r\n                <link rel=\"self\" href=\"http://example.com/entry/33\" />\r\n                <content type=\"application/vnd.example.document+xml\">\r\n                    <title>HR policies</title>\r\n                    <link href=\"http://example.com/cms/pdf/456\" />\r\n                </content>\r\n            </entry>\r\n            <entry>\r\n                <id>urn:uuid:1d3334a0-75bd-11e2-bcfd-0800200c9a66</id>\r\n                <title type=\"text\">User created</title>\r\n                <updated>2013-01-02T07:31:00Z</updated>\r\n                <author>\r\n                    <name>dgonzales</name>\r\n                </author>\r\n                <link rel=\"self\" href=\"http://example.com/entry/32\" />\r\n                <content type=\"application/vnd.example.user+xml\">\r\n                    <username>jsmith</username>\r\n                    <role>editor</role>\r\n                    <email>jsmith@example.com</email>\r\n                </content>\r\n            </entry>\r\n        </feed>\r\n\r\nAtom is optimised and designed for RESTful systems that communicate over HTTP.\r\n\r\nAtom is a general-purpose format that can be extended to fit a particular domain. By using a well-understood general-purpose format as a basis, we can reuse tools, infrastructure and semantics. The Atom syndication format was formalised in [RFC 4287](http://www.ietf.org/rfc/rfc4287).\r\n\r\nEvent-driven systems\r\n--------------------\r\n\r\nAtom can be used to implement event-driven systems by adding an entry to the feed every time something happens that subscribers might be interested in. Subscribers find out about these events by polling the feed. When new subscribers arrive, they can simply also start polling the feed without any change needed to the service.\r\n\r\nDepending on the nature of the event and the size of the resource that it applies to, the Atom entry could either include a snapshot of the new state of the resource, or simply link to the resource so that the client can issue a fresh GET.\r\n\r\nBecause Atom is based on polling, it has high latency compared to other approaches, which might make it unsuitable for real time systems. However, using a RESTful polling approach decouples client and server, and provides scalability through the opportunity for heavy caching.\r\n\r\nA simple protocol\r\n-----------------\r\n\r\n\"Atom\" can also sometimes refer to [AtomPub](https://tools.ietf.org/html/rfc5023), a protocol for editing and publishing web resources built on top of the Atom XML format.\r\n\r\nWe are not concerned with editing or writing to feeds. We will describe a simplified form of AtomPub suitable for broadcasting events to multiple consumers, and assume the server hosting the service has some way of recognising and registering new events as Atom entries.\r\n\r\nAs well as conforming to the restrictions of the Atom XML format, our protocol is based on the following rules:\r\n* Entries are ordered by the time they were added to the feed, from newest to oldest.\r\n* An entry, once published, never changes.\r\n* The series of entries is paginated over many Atom documents.\r\n* All documents except the oldest will have a link with rel \"next-archive\" pointing to the next document in the feed.\r\n* All documents except the newest will have a link with rel \"prev-archive\" pointing to the previous document in the feed. \r\n* Only the most recent document may change, and that can only change by newer events being prepended to it.\r\n* When the server decides the most recent document is finished, it archives that document and creates a new document.\r\n* There is a published URL that always points to the most recent document and serves as an entry point to the feed.\r\n\r\nThough it is good practice to use intuitive URLs, the protocol in no way depends on the structure of the URLs. Consumers should follow links, and not attempt to construct URLs themselves.\r\n\r\nPaginating feeds\r\n----------------\r\n\r\nAs Atom entries are intended to be available indefinitely, the feed of events can grow very large over time. This makes the feed too large for consumers to conveniently GET over a network.\r\n\r\nThe solution is to break up a single logical feed into many documents. As Atom is designed to follow RESTful conventions, Atom does this by means of links.\r\n\r\nThe server breaks up the series of events into separate documents and gives each of them their own URL. The server might choose to make each document represent a period of time e.g. a day, or might divide the series of events evenly so that each document has e.g. 100 entries. \r\n\r\nSimilar to a doubly-linked list, each document has *prev-archive* and *next-archive* links that can be followed to find the next document in the chain.\r\n\r\nThere is one special document known as the recent document, which holds the most recent entries. This document does not have a *next* link because it is at the head of the list.\r\n\r\nThe recent document is the published entry point to the feed. Consumers of the event feed will always be able to retrieve http://example.com/recent to get the most recent entries.\r\n\r\nDocuments older than the recent one are known as archived documents. Archived documents do not change after they have been created, but the recent document will continue to have entries prepended to it until the server archives it. This means that caching can be much more agressive for archived documents than the recent document.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Recent notifications</title>\r\n            <link rel=\"self\" href=\"http://example.com/recent\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/3\" />\r\n            <!-- There is no \"next-archive\" link as this is the most recent document. -->\r\n            <link rel=\"via\" href=\"http://example.com/documents/4\" />\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n        </feed>\r\n\r\nThe recent document can also be accessed through its permanent URL, which is represented with a \"via\" link. Once the server has archived the current recent document, it will create a new one and leave the via link intact.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Notifications</title>\r\n            <link rel=\"self\" href=\"http://example.com/documents/4\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/3\" />\r\n            <!-- There is no \"next-archive\" link as this is the most recent document. -->\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n        </feed>\r\n\r\nConsumers who are interested in older entries can follow the \"prev-archive\" link to the previous document.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Notifications</title>\r\n            <link rel=\"self\" href=\"http://example.com/documents/3\" />\r\n            <link rel=\"next-archive\" href=\"http://example.com/documents/4\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/2\" />\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n        </feed>\r\n\r\nThis document has been archived, and should therefore never change. Consumers wishing to find older or newer entries than the ones in this document can find them by following the \"prev-archive\" and \"next-archive\" links respectively. \r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Notifications</title>\r\n            <link rel=\"self\" href=\"http://example.com/documents/2\" />\r\n            <link rel=\"next-archive\" href=\"http://example.com/documents/3\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/1\" />\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n        </feed>\r\n\r\nThis is another archived document, and can also be heavily cached. Finding older or newer entries is again a matter of following the \"prev-archive\" or \"next-archive\" links. Consumers who wish to read the entire history can continue to follow \"prev-archive\" links until they come across a document with no such link, which will be the first.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <id>urn:uuid:ff31a040-75bc-11e2-bcfd-0800200c9a66</id>\r\n            <title type=\"text\">Notifications</title>\r\n            <link rel=\"self\" href=\"http://example.com/documents/1\" />\r\n            <link rel=\"next-archive\" href=\"http://example.com/documents/2\" />\r\n            <!-- There is no \"prev-archive\" link as this is the first document. -->\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n            <entry>..</entry>\r\n        </feed>\r\n\r\nConsuming feeds\r\n---------------\r\n\r\nA consumer of an Atom feed keeps track of the unique identifier of the most recent entry it has processed. Because the entries are time ordered, and the only change is to add new entries onto the front of the feed, consumers can work backwards till they find the oldest entry they have not yet processed, and then work forwards through the feed processing each event in turn. \r\n\r\nFor example, a consumer might know that it has most recently processed the entry with id \"urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66\".\r\n\r\nThis consumer wants to check if there are any more recent entries, so it issues a GET request on http://example.com/recent, which is the published entry-point of the feed.\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <link rel=\"self\" href=\"http://example.com/recent\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/3\" />\r\n            <link rel=\"via\" href=\"http://example.com/documents/4\" />\r\n            <entry>\r\n                <id>urn:uuid:e2089090-75c7-11e2-bcfd-0800200c9a66</id>\r\n            </entry>\r\n            <entry>\r\n                <id>urn:uuid:d765c950-75c7-11e2-bcfd-0800200c9a66</id>\r\n            </entry>\r\n        </feed>\r\n\r\nThe entry with id \"urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66\" is not present. This is because since the consumer last checked the feed, the server has added new entries to the front of the feed, archiving a document and starting a new one in the process.\r\n\r\nThe consumer therefore issues a GET request for the previous document, which has the URL \"http://example.com/documents/3\".\r\n\r\n    <?xml version=\"1.0\">\r\n        <feed xmlns=\"http://www.w3.org/2005/Atom\">\r\n            <link rel=\"self\" href=\"http://example.com/documents/3\" />\r\n            <link rel=\"next-archive\" href=\"http://example.com/documents/4\" />\r\n            <link rel=\"prev-archive\" href=\"http://example.com/documents/2\" />\r\n            <entry>\r\n                <id>urn:uuid:f37a81d0-75c7-11e2-bcfd-0800200c9a66</id>\r\n            </entry>\r\n            <entry>\r\n                <id>urn:uuid:fc374b00-75c7-11e2-bcfd-0800200c9a66</id>\r\n            </entry>\r\n        </feed>\r\n\r\nThis time, the consumer does find the entry it last processed. The consumer can now start to work its way back to the front of the feed, by processing the one new entry in document 3, and then going through the entries in the recent document.\r\n\r\nAs the consumer goes through the entries, it keeps updating its record of the most recent entry processed. Note that because the series of entries is time-ordered, the client need only keep track of the identifier of the most recent entry it has processed.\r\n\r\nNotice that the service does not have to keep track of who the consumers are or which entry they are each up to. The guarantee that new events are always added to the front of the list allows consumers to do that for themselves.\r\n\r\n![Documents are chained using next-archive and prev-archive links](Atom.png \"Chaining documents\")\r\n\r\nImplementation considerations\r\n-----------------------------\r\n\r\nOne of the biggest advantages to using Atom is caching. Servers should serve archived documents with aggressive Cache-Control headers, because once a document is archived, it does not change. Servers can take advantage of this by writing archived documents out to disk and serving them as static files.\r\n\r\nNote that this caching is possible because the pagination of entries into documents is controlled by the server. If every consumer could decide how to break up the series of entries, we would have to cache many different pagination combinations.\r\n\r\nConsumers should not care how pagination is implemented, because they simply follow links and retrieve resources. The server might choose to break the feed into time periods e.g. a document per day. However, if the flow of events is irregular, that could lead to some documents being very large and others being very small. This can be addressed by keeping a fixed number of entries per document.\r\n\r\nCache-Control headers on the recent document are limited by the freshness requirements of the system. It may still worthwhile allowing consumers and HTTP caches to cache the recent document for a short period of time, as it can reduce load on the server, but the length of time in the header must take into account how quickly consumers need to find out about new events.\r\n\r\nFor example, in a system with heavy load, using Cache-Control headers with a short time-to-live in conjunction with a reverse proxy gives an upper-bound on how often the server needs to generate the recent document. For example, a time-to-live of 60 seconds means that the origin server will only have to generate the recent document once per minute, regardless of how many consumers there are.\r\n\r\nAnother useful optimisation for the recent document are ETags and Last-Modified headers. Consumers poll the recent document potentially very often, so if they are able to issue a conditional GET accompanied by an ETag or Last-Modified date then the server can simply reply with a 304 Not Modified response and avoid transfering the entire recent document to the client.\r\n\r\nReferences\r\n----------\r\n\r\nA great reference for understanding Atom's use in RESTful event-driven systems is Chapter 7 of [REST in Practice](http://restinpractice.com/book/) by Jim Webber, Savas Parastatidis and Ian Robinson.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}